/* tslint:disable */
/* eslint-disable */
/**
 * Onfido API v3.6
 * The Onfido API
 *
 * The version of the OpenAPI document: 3.6.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import { Addresses } from '../model';
// @ts-ignore
import { Applicant } from '../model';
// @ts-ignore
import { ApplicantBuilder } from '../model';
// @ts-ignore
import { ApplicantsList } from '../model';
// @ts-ignore
import { Check } from '../model';
// @ts-ignore
import { CheckBuilder } from '../model';
// @ts-ignore
import { ChecksList } from '../model';
// @ts-ignore
import { CompleteTaskRequest } from '../model';
// @ts-ignore
import { CountryCodes } from '../model';
// @ts-ignore
import { Document } from '../model';
// @ts-ignore
import { DocumentsList } from '../model';
// @ts-ignore
import { Error1 } from '../model';
// @ts-ignore
import { ExtractRequest } from '../model';
// @ts-ignore
import { Extraction } from '../model';
// @ts-ignore
import { GenerateSdkTokenRequest } from '../model';
// @ts-ignore
import { IDPhotosList } from '../model';
// @ts-ignore
import { IdPhoto } from '../model';
// @ts-ignore
import { LivePhoto } from '../model';
// @ts-ignore
import { LivePhotosList } from '../model';
// @ts-ignore
import { LiveVideo } from '../model';
// @ts-ignore
import { LiveoVideosList } from '../model';
// @ts-ignore
import { LocationBuilder } from '../model';
// @ts-ignore
import { MotionCapture } from '../model';
// @ts-ignore
import { MotionCapturesList } from '../model';
// @ts-ignore
import { RepeatAttempts } from '../model';
// @ts-ignore
import { Report } from '../model';
// @ts-ignore
import { ReportsList } from '../model';
// @ts-ignore
import { ResultsFeedback } from '../model';
// @ts-ignore
import { SDKToken } from '../model';
// @ts-ignore
import { Task } from '../model';
// @ts-ignore
import { UpdateMonitorMatchRequest } from '../model';
// @ts-ignore
import { WatchlistMonitor } from '../model';
// @ts-ignore
import { WatchlistMonitorMatch } from '../model';
// @ts-ignore
import { Webhook } from '../model';
// @ts-ignore
import { WebhookBuilder } from '../model';
// @ts-ignore
import { WebhookResend } from '../model';
// @ts-ignore
import { WebhookUpdater } from '../model';
// @ts-ignore
import { WebhooksList } from '../model';
// @ts-ignore
import { WorkflowRun } from '../model';
// @ts-ignore
import { WorkflowRunBuilder } from '../model';
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary This endpoint is for cancelling individual paused reports.
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport: async (reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('cancelReport', 'reportId', reportId)
            const localVarPath = `/reports/{report_id}/cancel`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Completes a Send / Receive Data task.
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to complete.
         * @param {CompleteTaskRequest} completeTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask: async (workflowRunId: string, taskId: string, completeTaskRequest: CompleteTaskRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('completeTask', 'workflowRunId', workflowRunId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('completeTask', 'taskId', taskId)
            // verify required parameter 'completeTaskRequest' is not null or undefined
            assertParamExists('completeTask', 'completeTaskRequest', completeTaskRequest)
            const localVarPath = `/workflow_runs/{workflow_run_id}/tasks/{task_id}/complete`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Applicant
         * @param {ApplicantBuilder} applicantBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicant: async (applicantBuilder: ApplicantBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantBuilder' is not null or undefined
            assertParamExists('createApplicant', 'applicantBuilder', applicantBuilder)
            const localVarPath = `/applicants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicantBuilder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a check
         * @param {CheckBuilder} checkBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheck: async (checkBuilder: CheckBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkBuilder' is not null or undefined
            assertParamExists('createCheck', 'checkBuilder', checkBuilder)
            const localVarPath = `/checks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkBuilder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new monitor for the applicant
         * @param {WatchlistMonitor} watchlistMonitor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchlistMonitor: async (watchlistMonitor: WatchlistMonitor, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'watchlistMonitor' is not null or undefined
            assertParamExists('createWatchlistMonitor', 'watchlistMonitor', watchlistMonitor)
            const localVarPath = `/watchlist_monitors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(watchlistMonitor, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a webhook
         * @param {WebhookBuilder} webhookBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (webhookBuilder: WebhookBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookBuilder' is not null or undefined
            assertParamExists('createWebhook', 'webhookBuilder', webhookBuilder)
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookBuilder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Workflow Run.
         * @param {WorkflowRunBuilder} workflowRunBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowRun: async (workflowRunBuilder: WorkflowRunBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunBuilder' is not null or undefined
            assertParamExists('createWorkflowRun', 'workflowRunBuilder', workflowRunBuilder)
            const localVarPath = `/workflow_runs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowRunBuilder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicant: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('deleteApplicant', 'applicantId', applicantId)
            const localVarPath = `/applicants/{applicant_id}`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deactivates the given monitor
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchlistMonitor: async (monitorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('deleteWatchlistMonitor', 'monitorId', monitorId)
            const localVarPath = `/watchlist_monitors/{monitor_id}`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download raw data for a check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCheck: async (checkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkId' is not null or undefined
            assertParamExists('downloadCheck', 'checkId', checkId)
            const localVarPath = `/checks/{check_id}/download`
                .replace(`{${"check_id"}}`, encodeURIComponent(String(checkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download raw data for a document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadDocument', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/download`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a documents raw data
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentVideo: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadDocumentVideo', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/video/download`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ID photos are downloaded using this endpoint.
         * @summary Download ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadIdPhoto: async (idPhotoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idPhotoId' is not null or undefined
            assertParamExists('downloadIdPhoto', 'idPhotoId', idPhotoId)
            const localVarPath = `/id_photos/{id_photo_id}/download`
                .replace(`{${"id_photo_id"}}`, encodeURIComponent(String(idPhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Live photos are downloaded using this endpoint.
         * @summary Download live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLivePhoto: async (livePhotoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'livePhotoId' is not null or undefined
            assertParamExists('downloadLivePhoto', 'livePhotoId', livePhotoId)
            const localVarPath = `/live_photos/{live_photo_id}/download`
                .replace(`{${"live_photo_id"}}`, encodeURIComponent(String(livePhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Live videos are downloaded using this endpoint.
         * @summary Download live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideo: async (liveVideoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'liveVideoId' is not null or undefined
            assertParamExists('downloadLiveVideo', 'liveVideoId', liveVideoId)
            const localVarPath = `/live_videos/{live_video_id}/download`
                .replace(`{${"live_video_id"}}`, encodeURIComponent(String(liveVideoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the binary data representing a single frame from a live video.
         * @summary Download live video frame
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideoFrame: async (liveVideoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'liveVideoId' is not null or undefined
            assertParamExists('downloadLiveVideoFrame', 'liveVideoId', liveVideoId)
            const localVarPath = `/live_videos/{live_video_id}/frame`
                .replace(`{${"live_video_id"}}`, encodeURIComponent(String(liveVideoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Motion captures are downloaded using this endpoint.
         * @summary Download motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCapture: async (motionCaptureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'motionCaptureId' is not null or undefined
            assertParamExists('downloadMotionCapture', 'motionCaptureId', motionCaptureId)
            const localVarPath = `/motion_captures/{motion_capture_id}/download`
                .replace(`{${"motion_capture_id"}}`, encodeURIComponent(String(motionCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
         * @summary Download motion capture frame
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCaptureFrame: async (motionCaptureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'motionCaptureId' is not null or undefined
            assertParamExists('downloadMotionCaptureFrame', 'motionCaptureId', motionCaptureId)
            const localVarPath = `/motion_captures/{motion_capture_id}/frame`
                .replace(`{${"motion_capture_id"}}`, encodeURIComponent(String(motionCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the signed evidence file for the designated Workflow Run
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSignedEvidenceFile: async (workflowRunId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('downloadSignedEvidenceFile', 'workflowRunId', workflowRunId)
            const localVarPath = `/workflow_runs/{workflow_run_id}/signed_evidence_file`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Extract information from a document
         * @param {ExtractRequest} extractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extract: async (extractRequest: ExtractRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'extractRequest' is not null or undefined
            assertParamExists('extract', 'extractRequest', extractRequest)
            const localVarPath = `/extractions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(extractRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for addresses by postcode
         * @param {string} postcode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAddresses: async (postcode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postcode' is not null or undefined
            assertParamExists('findAddresses', 'postcode', postcode)
            const localVarPath = `/addresses/pick`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (postcode !== undefined) {
                localVarQueryParameter['postcode'] = postcode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplicant: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('findApplicant', 'applicantId', applicantId)
            const localVarPath = `/applicants/{applicant_id}`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a Check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCheck: async (checkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkId' is not null or undefined
            assertParamExists('findCheck', 'checkId', checkId)
            const localVarPath = `/checks/{check_id}`
                .replace(`{${"check_id"}}`, encodeURIComponent(String(checkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary A single document can be retrieved by calling this endpoint with the document\'s unique identifier.
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDocument: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('findDocument', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIdPhoto: async (idPhotoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idPhotoId' is not null or undefined
            assertParamExists('findIdPhoto', 'idPhotoId', idPhotoId)
            const localVarPath = `/id_photos/{id_photo_id}`
                .replace(`{${"id_photo_id"}}`, encodeURIComponent(String(idPhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLivePhoto: async (livePhotoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'livePhotoId' is not null or undefined
            assertParamExists('findLivePhoto', 'livePhotoId', livePhotoId)
            const localVarPath = `/live_photos/{live_photo_id}`
                .replace(`{${"live_photo_id"}}`, encodeURIComponent(String(livePhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLiveVideo: async (liveVideoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'liveVideoId' is not null or undefined
            assertParamExists('findLiveVideo', 'liveVideoId', liveVideoId)
            const localVarPath = `/live_videos/{live_video_id}`
                .replace(`{${"live_video_id"}}`, encodeURIComponent(String(liveVideoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMotionCapture: async (motionCaptureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'motionCaptureId' is not null or undefined
            assertParamExists('findMotionCapture', 'motionCaptureId', motionCaptureId)
            const localVarPath = `/motion_captures/{motion_capture_id}`
                .replace(`{${"motion_capture_id"}}`, encodeURIComponent(String(motionCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary A single report can be retrieved using this endpoint with the corresponding unique identifier.
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findReport: async (reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('findReport', 'reportId', reportId)
            const localVarPath = `/reports/{report_id}`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a single monitor
         * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWatchlistMonitor: async (monitorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('findWatchlistMonitor', 'monitorId', monitorId)
            const localVarPath = `/watchlist_monitors/{monitor_id}`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a Webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('findWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkflowRun: async (workflowRunId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('findWorkflowRun', 'workflowRunId', workflowRunId)
            const localVarPath = `/workflow_runs/{workflow_run_id}`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Force new report creation (BETA)
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceNewRecordCreation: async (monitorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('forceNewRecordCreation', 'monitorId', monitorId)
            const localVarPath = `/watchlist_monitors/{monitor_id}/new_report`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a SDK token
         * @param {GenerateSdkTokenRequest} generateSdkTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSdkToken: async (generateSdkTokenRequest: GenerateSdkTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateSdkTokenRequest' is not null or undefined
            assertParamExists('generateSdkToken', 'generateSdkTokenRequest', generateSdkTokenRequest)
            const localVarPath = `/sdk_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateSdkTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Applicants
         * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
         * @param {number} [perPage] The number of objects per page.
         * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicants: async (page?: number, perPage?: number, includeDeleted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/applicants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Checks
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChecks: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listChecks', 'applicantId', applicantId)
            const localVarPath = `/checks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All documents belonging to an applicant can be listed from this endpoint
         * @summary List documents
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listDocuments', 'applicantId', applicantId)
            const localVarPath = `/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List ID photos
         * @param {string} applicantId The id of the applicant the ID photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdPhotos: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listIdPhotos', 'applicantId', applicantId)
            const localVarPath = `/id_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List live photos
         * @param {string} applicantId The id of the applicant the live photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLivePhotos: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listLivePhotos', 'applicantId', applicantId)
            const localVarPath = `/live_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List live videos
         * @param {string} applicantId The id of the applicant the live videos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLiveVideos: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listLiveVideos', 'applicantId', applicantId)
            const localVarPath = `/live_videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List motion captures
         * @param {string} applicantId The id of the applicant the motion captures belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMotionCaptures: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listMotionCaptures', 'applicantId', applicantId)
            const localVarPath = `/motion_captures`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all repeat attempts for a given Document report.
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepeatAttempts: async (reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('listRepeatAttempts', 'reportId', reportId)
            const localVarPath = `/repeat_attempts/{report_id}`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary All the reports belonging to a particular check can be listed from this endpoint.
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReports: async (checkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkId' is not null or undefined
            assertParamExists('listReports', 'checkId', checkId)
            const localVarPath = `/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (checkId !== undefined) {
                localVarQueryParameter['check_id'] = checkId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks: async (workflowRunId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('listTasks', 'workflowRunId', workflowRunId)
            const localVarPath = `/workflow_runs/{workflow_run_id}/tasks`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List match IDs on this monitor, as well as their enabled/disabled status
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitorMatches: async (monitorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('listWatchlistMonitorMatches', 'monitorId', monitorId)
            const localVarPath = `/watchlist_monitors/{monitor_id}/matches`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all available monitors for an applicant
         * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
         * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitors: async (applicantId: string, includeDeleted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listWatchlistMonitors', 'applicantId', applicantId)
            const localVarPath = `/watchlist_monitors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Workflow Runs.
         * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
         * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
         * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
         * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
         * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRuns: async (page?: number, status?: string, createdAtGt?: string, createdAtLt?: string, sort?: ListWorkflowRunsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflow_runs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (createdAtGt !== undefined) {
                localVarQueryParameter['created_at_gt'] = (createdAtGt as any instanceof Date) ?
                    (createdAtGt as any).toISOString() :
                    createdAtGt;
            }

            if (createdAtLt !== undefined) {
                localVarQueryParameter['created_at_lt'] = (createdAtLt as any instanceof Date) ?
                    (createdAtLt as any).toISOString() :
                    createdAtLt;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run a health check on the Onfido API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Feedback on checks and reports (ALPHA)
         * @param {ResultsFeedback} resultsFeedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postResultsFeedback: async (resultsFeedback: ResultsFeedback, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resultsFeedback' is not null or undefined
            assertParamExists('postResultsFeedback', 'resultsFeedback', resultsFeedback)
            const localVarPath = `/results_feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resultsFeedback, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resends webhooks
         * @param {WebhookResend} webhookResend 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhooks: async (webhookResend: WebhookResend, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookResend' is not null or undefined
            assertParamExists('resendWebhooks', 'webhookResend', webhookResend)
            const localVarPath = `/webhooks/resend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookResend, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreApplicant: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('restoreApplicant', 'applicantId', applicantId)
            const localVarPath = `/applicants/{applicant_id}/restore`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resume a Check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeCheck: async (checkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkId' is not null or undefined
            assertParamExists('resumeCheck', 'checkId', checkId)
            const localVarPath = `/checks/{check_id}/resume`
                .replace(`{${"check_id"}}`, encodeURIComponent(String(checkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This endpoint is for resuming individual paused reports.
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeReport: async (reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('resumeReport', 'reportId', reportId)
            const localVarPath = `/reports/{report_id}/resume`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run.
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveTask: async (workflowRunId: string, taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('retrieveTask', 'workflowRunId', workflowRunId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('retrieveTask', 'taskId', taskId)
            const localVarPath = `/workflow_runs/{workflow_run_id}/tasks/{task_id}`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant 
         * @summary Update Applicant
         * @param {string} applicantId 
         * @param {ApplicantBuilder} applicantBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicant: async (applicantId: string, applicantBuilder: ApplicantBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('updateApplicant', 'applicantId', applicantId)
            // verify required parameter 'applicantBuilder' is not null or undefined
            assertParamExists('updateApplicant', 'applicantBuilder', applicantBuilder)
            const localVarPath = `/applicants/{applicant_id}`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicantBuilder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the status of the given matches.
         * @param {string} monitorId 
         * @param {UpdateMonitorMatchRequest} updateMonitorMatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMonitorMatch: async (monitorId: string, updateMonitorMatchRequest: UpdateMonitorMatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('updateMonitorMatch', 'monitorId', monitorId)
            // verify required parameter 'updateMonitorMatchRequest' is not null or undefined
            assertParamExists('updateMonitorMatch', 'updateMonitorMatchRequest', updateMonitorMatchRequest)
            const localVarPath = `/watchlist_monitors/{monitor_id}/matches`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMonitorMatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a webhook
         * @param {string} webhookId 
         * @param {WebhookUpdater} webhookUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (webhookId: string, webhookUpdater: WebhookUpdater, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateWebhook', 'webhookId', webhookId)
            // verify required parameter 'webhookUpdater' is not null or undefined
            assertParamExists('updateWebhook', 'webhookUpdater', webhookUpdater)
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookUpdater, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB. 
         * @summary Upload a document
         * @param {string} type The type of document
         * @param {string} applicantId The ID of the applicant whose document is being uploaded.
         * @param {File} file The file to be uploaded.
         * @param {UploadDocumentFileTypeEnum} [fileType] The file type of the uploaded file
         * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
         * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
         * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
         * @param {LocationBuilder} [location] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocument: async (type: string, applicantId: string, file: File, fileType?: UploadDocumentFileTypeEnum, side?: UploadDocumentSideEnum, issuingCountry?: CountryCodes, validateImageQuality?: boolean, location?: LocationBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('uploadDocument', 'type', type)
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('uploadDocument', 'applicantId', applicantId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadDocument', 'file', file)
            const localVarPath = `/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (fileType !== undefined) { 
                localVarFormParams.append('file_type', fileType as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.append('type', type as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.append('side', side as any);
            }
    
            if (issuingCountry !== undefined) { 
                localVarFormParams.append('issuing_country', issuingCountry as any);
            }
    
            if (applicantId !== undefined) { 
                localVarFormParams.append('applicant_id', applicantId as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (validateImageQuality !== undefined) { 
                localVarFormParams.append('validate_image_quality', validateImageQuality as any);
            }
    
            if (location !== undefined) { 
                localVarFormParams.append('location', new Blob([JSON.stringify(location)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. 
         * @summary Upload ID photo
         * @param {string} applicantId The ID of the applicant whose ID photo is being uploaded.
         * @param {File} file The file to be uploaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadIdPhoto: async (applicantId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('uploadIdPhoto', 'applicantId', applicantId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadIdPhoto', 'file', file)
            const localVarPath = `/id_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (applicantId !== undefined) { 
                localVarFormParams.append('applicant_id', applicantId as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false. 
         * @summary Upload live photo
         * @param {string} applicantId The ID of the applicant whose live photo is being uploaded.
         * @param {File} file The file to be uploaded.
         * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadLivePhoto: async (applicantId: string, file: File, advancedValidation?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('uploadLivePhoto', 'applicantId', applicantId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadLivePhoto', 'file', file)
            const localVarPath = `/live_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (applicantId !== undefined) { 
                localVarFormParams.append('applicant_id', applicantId as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (advancedValidation !== undefined) { 
                localVarFormParams.append('advanced_validation', advancedValidation as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary This endpoint is for cancelling individual paused reports.
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelReport(reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelReport(reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.cancelReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Completes a Send / Receive Data task.
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to complete.
         * @param {CompleteTaskRequest} completeTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeTask(workflowRunId: string, taskId: string, completeTaskRequest: CompleteTaskRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeTask(workflowRunId, taskId, completeTaskRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.completeTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Applicant
         * @param {ApplicantBuilder} applicantBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicant(applicantBuilder: ApplicantBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Applicant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicant(applicantBuilder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createApplicant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a check
         * @param {CheckBuilder} checkBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheck(checkBuilder: CheckBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Check>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheck(checkBuilder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a new monitor for the applicant
         * @param {WatchlistMonitor} watchlistMonitor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWatchlistMonitor(watchlistMonitor: WatchlistMonitor, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchlistMonitor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWatchlistMonitor(watchlistMonitor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createWatchlistMonitor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a webhook
         * @param {WebhookBuilder} webhookBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(webhookBuilder: WebhookBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(webhookBuilder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a Workflow Run.
         * @param {WorkflowRunBuilder} workflowRunBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflowRun(workflowRunBuilder: WorkflowRunBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflowRun(workflowRunBuilder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createWorkflowRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicant(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicant(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteApplicant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deactivates the given monitor
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWatchlistMonitor(monitorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWatchlistMonitor(monitorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteWatchlistMonitor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download raw data for a check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadCheck(checkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadCheck(checkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download raw data for a document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadDocument(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadDocument(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a documents raw data
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadDocumentVideo(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadDocumentVideo(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadDocumentVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ID photos are downloaded using this endpoint.
         * @summary Download ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadIdPhoto(idPhotoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadIdPhoto(idPhotoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadIdPhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Live photos are downloaded using this endpoint.
         * @summary Download live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadLivePhoto(livePhotoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadLivePhoto(livePhotoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadLivePhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Live videos are downloaded using this endpoint.
         * @summary Download live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadLiveVideo(liveVideoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadLiveVideo(liveVideoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadLiveVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the binary data representing a single frame from a live video.
         * @summary Download live video frame
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadLiveVideoFrame(liveVideoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadLiveVideoFrame(liveVideoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadLiveVideoFrame']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Motion captures are downloaded using this endpoint.
         * @summary Download motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadMotionCapture(motionCaptureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadMotionCapture(motionCaptureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadMotionCapture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
         * @summary Download motion capture frame
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadMotionCaptureFrame(motionCaptureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadMotionCaptureFrame(motionCaptureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadMotionCaptureFrame']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves the signed evidence file for the designated Workflow Run
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadSignedEvidenceFile(workflowRunId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSignedEvidenceFile(workflowRunId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadSignedEvidenceFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Extract information from a document
         * @param {ExtractRequest} extractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extract(extractRequest: ExtractRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Extraction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extract(extractRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.extract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search for addresses by postcode
         * @param {string} postcode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAddresses(postcode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Addresses>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAddresses(postcode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findAddresses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findApplicant(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Applicant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findApplicant(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findApplicant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a Check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findCheck(checkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Check>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findCheck(checkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary A single document can be retrieved by calling this endpoint with the document\'s unique identifier.
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDocument(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDocument(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findIdPhoto(idPhotoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdPhoto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findIdPhoto(idPhotoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findIdPhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findLivePhoto(livePhotoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LivePhoto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findLivePhoto(livePhotoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findLivePhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findLiveVideo(liveVideoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveVideo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findLiveVideo(liveVideoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findLiveVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMotionCapture(motionCaptureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MotionCapture>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMotionCapture(motionCaptureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findMotionCapture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary A single report can be retrieved using this endpoint with the corresponding unique identifier.
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findReport(reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findReport(reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a single monitor
         * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findWatchlistMonitor(monitorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchlistMonitor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findWatchlistMonitor(monitorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findWatchlistMonitor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a Webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findWebhook(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findWorkflowRun(workflowRunId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findWorkflowRun(workflowRunId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findWorkflowRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Force new report creation (BETA)
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forceNewRecordCreation(monitorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Applicant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forceNewRecordCreation(monitorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.forceNewRecordCreation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generate a SDK token
         * @param {GenerateSdkTokenRequest} generateSdkTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateSdkToken(generateSdkTokenRequest: GenerateSdkTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SDKToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateSdkToken(generateSdkTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.generateSdkToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Applicants
         * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
         * @param {number} [perPage] The number of objects per page.
         * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicants(page?: number, perPage?: number, includeDeleted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicantsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicants(page, perPage, includeDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listApplicants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve Checks
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChecks(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChecksList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChecks(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listChecks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * All documents belonging to an applicant can be listed from this endpoint
         * @summary List documents
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDocuments(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDocuments(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List ID photos
         * @param {string} applicantId The id of the applicant the ID photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIdPhotos(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IDPhotosList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdPhotos(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listIdPhotos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List live photos
         * @param {string} applicantId The id of the applicant the live photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLivePhotos(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LivePhotosList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLivePhotos(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listLivePhotos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List live videos
         * @param {string} applicantId The id of the applicant the live videos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLiveVideos(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveoVideosList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLiveVideos(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listLiveVideos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List motion captures
         * @param {string} applicantId The id of the applicant the motion captures belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMotionCaptures(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MotionCapturesList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMotionCaptures(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listMotionCaptures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all repeat attempts for a given Document report.
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRepeatAttempts(reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepeatAttempts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRepeatAttempts(reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listRepeatAttempts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary All the reports belonging to a particular check can be listed from this endpoint.
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listReports(checkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listReports(checkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listReports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTasks(workflowRunId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTasks(workflowRunId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List match IDs on this monitor, as well as their enabled/disabled status
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWatchlistMonitorMatches(monitorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WatchlistMonitorMatch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWatchlistMonitorMatches(monitorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listWatchlistMonitorMatches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all available monitors for an applicant
         * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
         * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWatchlistMonitors(applicantId: string, includeDeleted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WatchlistMonitor>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWatchlistMonitors(applicantId, includeDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listWatchlistMonitors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebhooks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhooksList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhooks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Workflow Runs.
         * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
         * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
         * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
         * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
         * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflowRuns(page?: number, status?: string, createdAtGt?: string, createdAtLt?: string, sort?: ListWorkflowRunsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listWorkflowRuns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Run a health check on the Onfido API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.ping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create Feedback on checks and reports (ALPHA)
         * @param {ResultsFeedback} resultsFeedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postResultsFeedback(resultsFeedback: ResultsFeedback, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultsFeedback>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postResultsFeedback(resultsFeedback, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postResultsFeedback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Resends webhooks
         * @param {WebhookResend} webhookResend 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendWebhooks(webhookResend: WebhookResend, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendWebhooks(webhookResend, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resendWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Restore Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreApplicant(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreApplicant(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.restoreApplicant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Resume a Check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resumeCheck(checkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resumeCheck(checkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resumeCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary This endpoint is for resuming individual paused reports.
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resumeReport(reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resumeReport(reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resumeReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run.
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveTask(workflowRunId: string, taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveTask(workflowRunId, taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.retrieveTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant 
         * @summary Update Applicant
         * @param {string} applicantId 
         * @param {ApplicantBuilder} applicantBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplicant(applicantId: string, applicantBuilder: ApplicantBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Applicant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplicant(applicantId, applicantBuilder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateApplicant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the status of the given matches.
         * @param {string} monitorId 
         * @param {UpdateMonitorMatchRequest} updateMonitorMatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMonitorMatch(monitorId: string, updateMonitorMatchRequest: UpdateMonitorMatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMonitorMatch(monitorId, updateMonitorMatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateMonitorMatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edit a webhook
         * @param {string} webhookId 
         * @param {WebhookUpdater} webhookUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(webhookId: string, webhookUpdater: WebhookUpdater, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(webhookId, webhookUpdater, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB. 
         * @summary Upload a document
         * @param {string} type The type of document
         * @param {string} applicantId The ID of the applicant whose document is being uploaded.
         * @param {File} file The file to be uploaded.
         * @param {UploadDocumentFileTypeEnum} [fileType] The file type of the uploaded file
         * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
         * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
         * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
         * @param {LocationBuilder} [location] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadDocument(type: string, applicantId: string, file: File, fileType?: UploadDocumentFileTypeEnum, side?: UploadDocumentSideEnum, issuingCountry?: CountryCodes, validateImageQuality?: boolean, location?: LocationBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. 
         * @summary Upload ID photo
         * @param {string} applicantId The ID of the applicant whose ID photo is being uploaded.
         * @param {File} file The file to be uploaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadIdPhoto(applicantId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdPhoto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadIdPhoto(applicantId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadIdPhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false. 
         * @summary Upload live photo
         * @param {string} applicantId The ID of the applicant whose live photo is being uploaded.
         * @param {File} file The file to be uploaded.
         * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadLivePhoto(applicantId: string, file: File, advancedValidation?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LivePhoto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadLivePhoto(applicantId, file, advancedValidation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadLivePhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary This endpoint is for cancelling individual paused reports.
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport(reportId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelReport(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Completes a Send / Receive Data task.
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to complete.
         * @param {CompleteTaskRequest} completeTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask(workflowRunId: string, taskId: string, completeTaskRequest: CompleteTaskRequest, options?: any): AxiosPromise<void> {
            return localVarFp.completeTask(workflowRunId, taskId, completeTaskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Applicant
         * @param {ApplicantBuilder} applicantBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicant(applicantBuilder: ApplicantBuilder, options?: any): AxiosPromise<Applicant> {
            return localVarFp.createApplicant(applicantBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a check
         * @param {CheckBuilder} checkBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheck(checkBuilder: CheckBuilder, options?: any): AxiosPromise<Check> {
            return localVarFp.createCheck(checkBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new monitor for the applicant
         * @param {WatchlistMonitor} watchlistMonitor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchlistMonitor(watchlistMonitor: WatchlistMonitor, options?: any): AxiosPromise<WatchlistMonitor> {
            return localVarFp.createWatchlistMonitor(watchlistMonitor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a webhook
         * @param {WebhookBuilder} webhookBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(webhookBuilder: WebhookBuilder, options?: any): AxiosPromise<Webhook> {
            return localVarFp.createWebhook(webhookBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Workflow Run.
         * @param {WorkflowRunBuilder} workflowRunBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowRun(workflowRunBuilder: WorkflowRunBuilder, options?: any): AxiosPromise<WorkflowRun> {
            return localVarFp.createWorkflowRun(workflowRunBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicant(applicantId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicant(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deactivates the given monitor
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchlistMonitor(monitorId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWatchlistMonitor(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download raw data for a check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCheck(checkId: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadCheck(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download raw data for a document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument(documentId: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadDocument(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a documents raw data
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentVideo(documentId: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadDocumentVideo(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * ID photos are downloaded using this endpoint.
         * @summary Download ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadIdPhoto(idPhotoId: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadIdPhoto(idPhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Live photos are downloaded using this endpoint.
         * @summary Download live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLivePhoto(livePhotoId: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadLivePhoto(livePhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Live videos are downloaded using this endpoint.
         * @summary Download live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideo(liveVideoId: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadLiveVideo(liveVideoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the binary data representing a single frame from a live video.
         * @summary Download live video frame
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideoFrame(liveVideoId: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadLiveVideoFrame(liveVideoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Motion captures are downloaded using this endpoint.
         * @summary Download motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCapture(motionCaptureId: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadMotionCapture(motionCaptureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
         * @summary Download motion capture frame
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCaptureFrame(motionCaptureId: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadMotionCaptureFrame(motionCaptureId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the signed evidence file for the designated Workflow Run
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSignedEvidenceFile(workflowRunId: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadSignedEvidenceFile(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Extract information from a document
         * @param {ExtractRequest} extractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extract(extractRequest: ExtractRequest, options?: any): AxiosPromise<Extraction> {
            return localVarFp.extract(extractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for addresses by postcode
         * @param {string} postcode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAddresses(postcode: string, options?: any): AxiosPromise<Addresses> {
            return localVarFp.findAddresses(postcode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplicant(applicantId: string, options?: any): AxiosPromise<Applicant> {
            return localVarFp.findApplicant(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a Check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCheck(checkId: string, options?: any): AxiosPromise<Check> {
            return localVarFp.findCheck(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary A single document can be retrieved by calling this endpoint with the document\'s unique identifier.
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDocument(documentId: string, options?: any): AxiosPromise<Document> {
            return localVarFp.findDocument(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIdPhoto(idPhotoId: string, options?: any): AxiosPromise<IdPhoto> {
            return localVarFp.findIdPhoto(idPhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLivePhoto(livePhotoId: string, options?: any): AxiosPromise<LivePhoto> {
            return localVarFp.findLivePhoto(livePhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLiveVideo(liveVideoId: string, options?: any): AxiosPromise<LiveVideo> {
            return localVarFp.findLiveVideo(liveVideoId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMotionCapture(motionCaptureId: string, options?: any): AxiosPromise<MotionCapture> {
            return localVarFp.findMotionCapture(motionCaptureId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary A single report can be retrieved using this endpoint with the corresponding unique identifier.
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findReport(reportId: string, options?: any): AxiosPromise<Report> {
            return localVarFp.findReport(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a single monitor
         * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWatchlistMonitor(monitorId: string, options?: any): AxiosPromise<WatchlistMonitor> {
            return localVarFp.findWatchlistMonitor(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a Webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWebhook(webhookId: string, options?: any): AxiosPromise<Webhook> {
            return localVarFp.findWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkflowRun(workflowRunId: string, options?: any): AxiosPromise<WorkflowRun> {
            return localVarFp.findWorkflowRun(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Force new report creation (BETA)
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceNewRecordCreation(monitorId: string, options?: any): AxiosPromise<Applicant> {
            return localVarFp.forceNewRecordCreation(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate a SDK token
         * @param {GenerateSdkTokenRequest} generateSdkTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSdkToken(generateSdkTokenRequest: GenerateSdkTokenRequest, options?: any): AxiosPromise<SDKToken> {
            return localVarFp.generateSdkToken(generateSdkTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Applicants
         * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
         * @param {number} [perPage] The number of objects per page.
         * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicants(page?: number, perPage?: number, includeDeleted?: boolean, options?: any): AxiosPromise<ApplicantsList> {
            return localVarFp.listApplicants(page, perPage, includeDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Checks
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChecks(applicantId: string, options?: any): AxiosPromise<ChecksList> {
            return localVarFp.listChecks(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * All documents belonging to an applicant can be listed from this endpoint
         * @summary List documents
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments(applicantId: string, options?: any): AxiosPromise<DocumentsList> {
            return localVarFp.listDocuments(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List ID photos
         * @param {string} applicantId The id of the applicant the ID photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdPhotos(applicantId: string, options?: any): AxiosPromise<IDPhotosList> {
            return localVarFp.listIdPhotos(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List live photos
         * @param {string} applicantId The id of the applicant the live photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLivePhotos(applicantId: string, options?: any): AxiosPromise<LivePhotosList> {
            return localVarFp.listLivePhotos(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List live videos
         * @param {string} applicantId The id of the applicant the live videos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLiveVideos(applicantId: string, options?: any): AxiosPromise<LiveoVideosList> {
            return localVarFp.listLiveVideos(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List motion captures
         * @param {string} applicantId The id of the applicant the motion captures belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMotionCaptures(applicantId: string, options?: any): AxiosPromise<MotionCapturesList> {
            return localVarFp.listMotionCaptures(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all repeat attempts for a given Document report.
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepeatAttempts(reportId: string, options?: any): AxiosPromise<RepeatAttempts> {
            return localVarFp.listRepeatAttempts(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary All the reports belonging to a particular check can be listed from this endpoint.
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReports(checkId: string, options?: any): AxiosPromise<ReportsList> {
            return localVarFp.listReports(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(workflowRunId: string, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.listTasks(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List match IDs on this monitor, as well as their enabled/disabled status
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitorMatches(monitorId: string, options?: any): AxiosPromise<Array<WatchlistMonitorMatch>> {
            return localVarFp.listWatchlistMonitorMatches(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all available monitors for an applicant
         * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
         * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitors(applicantId: string, includeDeleted?: boolean, options?: any): AxiosPromise<Array<WatchlistMonitor>> {
            return localVarFp.listWatchlistMonitors(applicantId, includeDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(options?: any): AxiosPromise<WebhooksList> {
            return localVarFp.listWebhooks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Workflow Runs.
         * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
         * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
         * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
         * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
         * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRuns(page?: number, status?: string, createdAtGt?: string, createdAtLt?: string, sort?: ListWorkflowRunsSortEnum, options?: any): AxiosPromise<Array<WorkflowRun>> {
            return localVarFp.listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run a health check on the Onfido API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<string> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Feedback on checks and reports (ALPHA)
         * @param {ResultsFeedback} resultsFeedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postResultsFeedback(resultsFeedback: ResultsFeedback, options?: any): AxiosPromise<ResultsFeedback> {
            return localVarFp.postResultsFeedback(resultsFeedback, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resends webhooks
         * @param {WebhookResend} webhookResend 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhooks(webhookResend: WebhookResend, options?: any): AxiosPromise<void> {
            return localVarFp.resendWebhooks(webhookResend, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreApplicant(applicantId: string, options?: any): AxiosPromise<void> {
            return localVarFp.restoreApplicant(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resume a Check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeCheck(checkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.resumeCheck(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary This endpoint is for resuming individual paused reports.
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeReport(reportId: string, options?: any): AxiosPromise<void> {
            return localVarFp.resumeReport(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run.
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveTask(workflowRunId: string, taskId: string, options?: any): AxiosPromise<Task> {
            return localVarFp.retrieveTask(workflowRunId, taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant 
         * @summary Update Applicant
         * @param {string} applicantId 
         * @param {ApplicantBuilder} applicantBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicant(applicantId: string, applicantBuilder: ApplicantBuilder, options?: any): AxiosPromise<Applicant> {
            return localVarFp.updateApplicant(applicantId, applicantBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the status of the given matches.
         * @param {string} monitorId 
         * @param {UpdateMonitorMatchRequest} updateMonitorMatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMonitorMatch(monitorId: string, updateMonitorMatchRequest: UpdateMonitorMatchRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateMonitorMatch(monitorId, updateMonitorMatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a webhook
         * @param {string} webhookId 
         * @param {WebhookUpdater} webhookUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId: string, webhookUpdater: WebhookUpdater, options?: any): AxiosPromise<Webhook> {
            return localVarFp.updateWebhook(webhookId, webhookUpdater, options).then((request) => request(axios, basePath));
        },
        /**
         * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB. 
         * @summary Upload a document
         * @param {string} type The type of document
         * @param {string} applicantId The ID of the applicant whose document is being uploaded.
         * @param {File} file The file to be uploaded.
         * @param {UploadDocumentFileTypeEnum} [fileType] The file type of the uploaded file
         * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
         * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
         * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
         * @param {LocationBuilder} [location] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocument(type: string, applicantId: string, file: File, fileType?: UploadDocumentFileTypeEnum, side?: UploadDocumentSideEnum, issuingCountry?: CountryCodes, validateImageQuality?: boolean, location?: LocationBuilder, options?: any): AxiosPromise<Document> {
            return localVarFp.uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options).then((request) => request(axios, basePath));
        },
        /**
         * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. 
         * @summary Upload ID photo
         * @param {string} applicantId The ID of the applicant whose ID photo is being uploaded.
         * @param {File} file The file to be uploaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadIdPhoto(applicantId: string, file: File, options?: any): AxiosPromise<IdPhoto> {
            return localVarFp.uploadIdPhoto(applicantId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false. 
         * @summary Upload live photo
         * @param {string} applicantId The ID of the applicant whose live photo is being uploaded.
         * @param {File} file The file to be uploaded.
         * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadLivePhoto(applicantId: string, file: File, advancedValidation?: boolean, options?: any): AxiosPromise<LivePhoto> {
            return localVarFp.uploadLivePhoto(applicantId, file, advancedValidation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary This endpoint is for cancelling individual paused reports.
     * @param {string} reportId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cancelReport(reportId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cancelReport(reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Completes a Send / Receive Data task.
     * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
     * @param {string} taskId The identifier of the Task you want to complete.
     * @param {CompleteTaskRequest} completeTaskRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public completeTask(workflowRunId: string, taskId: string, completeTaskRequest: CompleteTaskRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).completeTask(workflowRunId, taskId, completeTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Applicant
     * @param {ApplicantBuilder} applicantBuilder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createApplicant(applicantBuilder: ApplicantBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createApplicant(applicantBuilder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a check
     * @param {CheckBuilder} checkBuilder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createCheck(checkBuilder: CheckBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createCheck(checkBuilder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new monitor for the applicant
     * @param {WatchlistMonitor} watchlistMonitor 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createWatchlistMonitor(watchlistMonitor: WatchlistMonitor, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createWatchlistMonitor(watchlistMonitor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a webhook
     * @param {WebhookBuilder} webhookBuilder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createWebhook(webhookBuilder: WebhookBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createWebhook(webhookBuilder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Workflow Run.
     * @param {WorkflowRunBuilder} workflowRunBuilder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createWorkflowRun(workflowRunBuilder: WorkflowRunBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createWorkflowRun(workflowRunBuilder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Applicant
     * @param {string} applicantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteApplicant(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteApplicant(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deactivates the given monitor
     * @param {string} monitorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteWatchlistMonitor(monitorId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteWatchlistMonitor(monitorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a webhook
     * @param {string} webhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download raw data for a check
     * @param {string} checkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadCheck(checkId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadCheck(checkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download raw data for a document
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadDocument(documentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadDocument(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a documents raw data
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadDocumentVideo(documentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadDocumentVideo(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ID photos are downloaded using this endpoint.
     * @summary Download ID photo
     * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadIdPhoto(idPhotoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadIdPhoto(idPhotoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Live photos are downloaded using this endpoint.
     * @summary Download live photo
     * @param {string} livePhotoId The live photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadLivePhoto(livePhotoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadLivePhoto(livePhotoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Live videos are downloaded using this endpoint.
     * @summary Download live video
     * @param {string} liveVideoId The live video\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadLiveVideo(liveVideoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadLiveVideo(liveVideoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the binary data representing a single frame from a live video.
     * @summary Download live video frame
     * @param {string} liveVideoId The live video\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadLiveVideoFrame(liveVideoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadLiveVideoFrame(liveVideoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Motion captures are downloaded using this endpoint.
     * @summary Download motion capture
     * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadMotionCapture(motionCaptureId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadMotionCapture(motionCaptureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
     * @summary Download motion capture frame
     * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadMotionCaptureFrame(motionCaptureId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadMotionCaptureFrame(motionCaptureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the signed evidence file for the designated Workflow Run
     * @param {string} workflowRunId Workflow Run ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadSignedEvidenceFile(workflowRunId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadSignedEvidenceFile(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Extract information from a document
     * @param {ExtractRequest} extractRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public extract(extractRequest: ExtractRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).extract(extractRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for addresses by postcode
     * @param {string} postcode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findAddresses(postcode: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findAddresses(postcode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Applicant
     * @param {string} applicantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findApplicant(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findApplicant(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a Check
     * @param {string} checkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findCheck(checkId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findCheck(checkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary A single document can be retrieved by calling this endpoint with the document\'s unique identifier.
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findDocument(documentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findDocument(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve ID photo
     * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findIdPhoto(idPhotoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findIdPhoto(idPhotoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve live photo
     * @param {string} livePhotoId The live photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findLivePhoto(livePhotoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findLivePhoto(livePhotoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve live video
     * @param {string} liveVideoId The live video\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findLiveVideo(liveVideoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findLiveVideo(liveVideoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve motion capture
     * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findMotionCapture(motionCaptureId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findMotionCapture(motionCaptureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary A single report can be retrieved using this endpoint with the corresponding unique identifier.
     * @param {string} reportId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findReport(reportId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findReport(reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a single monitor
     * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findWatchlistMonitor(monitorId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findWatchlistMonitor(monitorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a Webhook
     * @param {string} webhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findWebhook(webhookId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
     * @param {string} workflowRunId The unique identifier of the Workflow Run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findWorkflowRun(workflowRunId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findWorkflowRun(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Force new report creation (BETA)
     * @param {string} monitorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public forceNewRecordCreation(monitorId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).forceNewRecordCreation(monitorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate a SDK token
     * @param {GenerateSdkTokenRequest} generateSdkTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public generateSdkToken(generateSdkTokenRequest: GenerateSdkTokenRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).generateSdkToken(generateSdkTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Applicants
     * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
     * @param {number} [perPage] The number of objects per page.
     * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listApplicants(page?: number, perPage?: number, includeDeleted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listApplicants(page, perPage, includeDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Checks
     * @param {string} applicantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listChecks(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listChecks(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All documents belonging to an applicant can be listed from this endpoint
     * @summary List documents
     * @param {string} applicantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listDocuments(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listDocuments(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List ID photos
     * @param {string} applicantId The id of the applicant the ID photos belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listIdPhotos(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listIdPhotos(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List live photos
     * @param {string} applicantId The id of the applicant the live photos belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listLivePhotos(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listLivePhotos(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List live videos
     * @param {string} applicantId The id of the applicant the live videos belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listLiveVideos(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listLiveVideos(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List motion captures
     * @param {string} applicantId The id of the applicant the motion captures belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listMotionCaptures(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listMotionCaptures(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all repeat attempts for a given Document report.
     * @param {string} reportId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listRepeatAttempts(reportId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listRepeatAttempts(reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary All the reports belonging to a particular check can be listed from this endpoint.
     * @param {string} checkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listReports(checkId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listReports(checkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
     * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTasks(workflowRunId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listTasks(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List match IDs on this monitor, as well as their enabled/disabled status
     * @param {string} monitorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listWatchlistMonitorMatches(monitorId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listWatchlistMonitorMatches(monitorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all available monitors for an applicant
     * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
     * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listWatchlistMonitors(applicantId: string, includeDeleted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listWatchlistMonitors(applicantId, includeDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listWebhooks(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listWebhooks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Workflow Runs.
     * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
     * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
     * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
     * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
     * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listWorkflowRuns(page?: number, status?: string, createdAtGt?: string, createdAtLt?: string, sort?: ListWorkflowRunsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run a health check on the Onfido API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public ping(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Feedback on checks and reports (ALPHA)
     * @param {ResultsFeedback} resultsFeedback 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postResultsFeedback(resultsFeedback: ResultsFeedback, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postResultsFeedback(resultsFeedback, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resends webhooks
     * @param {WebhookResend} webhookResend 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resendWebhooks(webhookResend: WebhookResend, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resendWebhooks(webhookResend, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore Applicant
     * @param {string} applicantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public restoreApplicant(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).restoreApplicant(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resume a Check
     * @param {string} checkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resumeCheck(checkId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resumeCheck(checkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary This endpoint is for resuming individual paused reports.
     * @param {string} reportId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resumeReport(reportId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resumeReport(reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run.
     * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
     * @param {string} taskId The identifier of the Task you want to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public retrieveTask(workflowRunId: string, taskId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).retrieveTask(workflowRunId, taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant 
     * @summary Update Applicant
     * @param {string} applicantId 
     * @param {ApplicantBuilder} applicantBuilder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateApplicant(applicantId: string, applicantBuilder: ApplicantBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateApplicant(applicantId, applicantBuilder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the status of the given matches.
     * @param {string} monitorId 
     * @param {UpdateMonitorMatchRequest} updateMonitorMatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateMonitorMatch(monitorId: string, updateMonitorMatchRequest: UpdateMonitorMatchRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateMonitorMatch(monitorId, updateMonitorMatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a webhook
     * @param {string} webhookId 
     * @param {WebhookUpdater} webhookUpdater 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateWebhook(webhookId: string, webhookUpdater: WebhookUpdater, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateWebhook(webhookId, webhookUpdater, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB. 
     * @summary Upload a document
     * @param {string} type The type of document
     * @param {string} applicantId The ID of the applicant whose document is being uploaded.
     * @param {File} file The file to be uploaded.
     * @param {UploadDocumentFileTypeEnum} [fileType] The file type of the uploaded file
     * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
     * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
     * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
     * @param {LocationBuilder} [location] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadDocument(type: string, applicantId: string, file: File, fileType?: UploadDocumentFileTypeEnum, side?: UploadDocumentSideEnum, issuingCountry?: CountryCodes, validateImageQuality?: boolean, location?: LocationBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. 
     * @summary Upload ID photo
     * @param {string} applicantId The ID of the applicant whose ID photo is being uploaded.
     * @param {File} file The file to be uploaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadIdPhoto(applicantId: string, file: File, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadIdPhoto(applicantId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false. 
     * @summary Upload live photo
     * @param {string} applicantId The ID of the applicant whose live photo is being uploaded.
     * @param {File} file The file to be uploaded.
     * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadLivePhoto(applicantId: string, file: File, advancedValidation?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadLivePhoto(applicantId, file, advancedValidation, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListWorkflowRunsSortEnum = {
    Desc: 'desc',
    Asc: 'asc',
    UnknownDefaultOpenApi: '11184809'
} as const;
export type ListWorkflowRunsSortEnum = typeof ListWorkflowRunsSortEnum[keyof typeof ListWorkflowRunsSortEnum];
/**
 * @export
 */
export const UploadDocumentFileTypeEnum = {
    Jpg: 'jpg',
    Png: 'png',
    Pdf: 'pdf',
    UnknownDefaultOpenApi: '11184809'
} as const;
export type UploadDocumentFileTypeEnum = typeof UploadDocumentFileTypeEnum[keyof typeof UploadDocumentFileTypeEnum];
/**
 * @export
 */
export const UploadDocumentSideEnum = {
    Front: 'front',
    Back: 'back',
    UnknownDefaultOpenApi: '11184809'
} as const;
export type UploadDocumentSideEnum = typeof UploadDocumentSideEnum[keyof typeof UploadDocumentSideEnum];
